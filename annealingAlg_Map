__author__ = 'karic_000'
import random
import math


def search_map():
    a, b, c, d, e, f, g, h, i, j, k = 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'
    letters = (a, b, c, d, e, f, g, h, i, j, k)

    g2, h10, c10, b3, g6, h3, e10, e12, h11, h5, g10 = ('Gates House', 'Grimson Hall',
                                                        'Hooper St. Lot', 'Spring St. Lot',
                                                        'Kelly Gymnasium', 'Woodard Hall',
                                                        'Burnell Hall', 'Tinsley Center',
                                                        'East Campus Commons',
                                                        'Davis Alumni Center',
                                                        'Burril Office Complex')
    places = (g2, h10, c10, b3, g6, h3, e10, e12, h11, h5, g10)

    location_options = []
    path_order = []

    #              [1 , 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18]
    location_map = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # A
                    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # B
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],  # C
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # D
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0],  # E
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # F
                    [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],  # G
                    [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],  # H
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # I
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # J
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]  # K

    index_in_matrix = 0  # Keeps track of index in matrix, and total elements (198 of them)
    row_index = 0   # Keeps track of row number during loop

    for row_letter in location_map:
        for number_index in row_letter:
            index_in_row = index_in_matrix - (18*row_index)  # # Keeps track of index in row
            if number_index == 1:  # If position is occupied
                # print("Row number:", row_index+1, "Column number:", index_in_row+1)
                row_index_to_letter(row_index, a, b, c, d, e, f, g, h, i, j, k)

                location_options.append([row_index, index_in_row])
                print("Location's coordinates:", letters[row_index], index_in_row+1)

                # Identify coordinates with locate_name
                locate_name(letters[row_index], row_index)
                # print("Letter:", letters[row_index], "Numbers:", row_index, "Index:", row_index)
                print("Place name:", places[row_index], "\n")

            index_in_matrix += 1
        row_index += 1
    print("Location options:", location_options)

    # Now create a random path to optimize
    while len(path_order) < len(location_options):  # from 0 - 10 (0<11)
        i = random.randint(0, 10)  # 11 options
        if location_options[i] not in path_order:  # Assure no items are being repeated
            path_order.append(location_options[i])

    print("This will be the randomly chosen path to be optimized:", path_order)
    let_d_alg_begin(path_order)


def let_d_alg_begin(path_order):

    done = False  # Algorithm can only be done once all places are visited
    visited_places = 11  # Keeps track of visited locations
    long_term_path = path_order  # path_order is the long term memory to be optimized
    old_path = []  # Saves a previous path in case the old one is better
    cycles = 0  # The number of cycles per iteration, 1000 is the max
    index = 1  # Starting from the second location
    loop_index = 0
    # p1, p2, q1, q2 = 0, 0, 0, 0
    # current_location, next_location, random_location = [], [], []  # Holds the pair of coordinates
    while not done:
        if cycles != 1000:
            for coordinates_pair in long_term_path:
                current_location = coordinates_pair
                next_location = long_term_path[index]  # Advance to next index
                p1, p2 = current_location[0], current_location[1]
                q1, q2 = next_location[0], next_location[1]
                old_path = long_term_path  # Back up of the current state which might be updated
                perform_randomize(loop_index, p1, p2, q1, q2, long_term_path)
                print("p1, p2, q1, q2, long_term_path:", p1, p2, q1, q2, long_term_path)
                # if old_path == long_term_path:
                    # check_global_min_distance()

                # Now check global error
                # if trial_error < global_best_error:
                    # global_best_error = trial_error
                    # global_best = item = item_long_memo
                loop_index += 1
            if visited_places == 0:  # While under 1000 cycles, once all places are visited, done.
                done = True
        else:
            done = True
            print()


def perform_randomize(index, p1, p2, q1, q2, long_term_path):

    path = long_term_path
    path2 = long_term_path  # Item will be "swapped"
    random_int = []  # Index for the random pair of coordinates
    # random_next, final_x1, final_x2 = [], 0, 0
    euclidean1, euclidean2 = 0, 0
    good_random = False

    while not good_random:
        random_int = random.randint(0, 10)
        if (path[random_int] != path(index)) and (path[random_int] != path(index+1)):
            random_next = long_term_path[random_int]
            x1, x2 = random_next[0], random_next[1]
            good_random = True

    # Calculate the two different path options
    if good_random:
        copy = long_term_path[index]  # Copies element that's being taken out to add somewhere else
        path2[index] = long_term_path[random_int]
        path2[random_int] = copy  # Substitute with the deleted element
        # Begin the euclidean distance comparisons
        for element in path:
            x1, x2 = path[element], path[element]
            y1, y2 = path[element+1], path[element+1]
            euclidean1 = euclidean1 + (math.sqrt(((x1-x1)**2) + ((y2-y2)**2)))
        print("euclidean1", euclidean1)
        for element in path2:
            x1, x2 = path2[element], path2[element]
            y1, y2 = path2[element+1], path2[element+1]
            euclidean2 = euclidean2 + (math.sqrt(((x1-x1)**2) + ((y2-y2)**2)))
        print("euclidean2", euclidean2)

        # DO A GLOBAL BEST TOO
        if euclidean2 < euclidean1:
            long_term_path = path2
        return long_term_path


def row_index_to_letter(index, a, b, c, d, e, f, g, h, i, j, k):
    letter = None
    if index == 0:
        letter = a
    if index == 1:
        letter = b
    if index == 2:
        letter = c
    if index == 3:
        letter = d
    if index == 4:
        letter = e
    if index == 5:
        letter = f
    if index == 6:
        letter = g
    if index == 7:
        letter = h
    if index == 8:
        letter = i
    if index == 9:
        letter = j
    if index == 10:
        letter = k
    return letter


def locate_name(letter, number):

    if letter == 'G' and number == 2:
        number = 0
        return number
    if letter == 'H' and number == 10:
        number = 1
        return number
    if letter == 'C' and number == 10:
        number = 2
        return number
    if letter == 'B' and number == 3:
        number = 3
        return number
    if letter == 'G' and number == 6:
        number = 4
        return number
    if letter == 'H' and number == 3:
        number = 5
        return number
    if letter == 'E' and number == 10:
        number = 6
        return number
    if letter == 'E' and number == 12:
        number = 7
        return number
    if letter == 'H' and number == 11:
        number = 8
        return number
    if letter == 'H' and number == 5:
        number = 9
        return number
    if letter == 'G' and number == 10:
        number = 10
        return number

search_map()
